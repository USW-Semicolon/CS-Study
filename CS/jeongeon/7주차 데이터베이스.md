# 4.데이터베이스

# 4.1 데이터베이스의 기본

- 일정한 규칙 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음
- DBMS를 통해 쿼리 언어로 데이터 삽입, 수정 조회 등을 수행

## 4.1.1 엔터티

- 엔터티는 사람, 장소, 물건, 사건 등 여러 개의 속성을 지닌 명사를 의미

### 약한 엔터티와 강한 엔터티

- 예로 A가 혼자서는 존재하지 못하고 B의 존재 여부에 따라 종속적이면 A는 약한 엔터티, B는 강한 엔터티이다

## 4.1.2 릴레이션

- 데이터베이스에서 정보를 구분하여 저장하는 기본 단위
- 릴레이션은 관계형 DB에서는 ‘테이블’, NoSQL에서는 ‘컬렉션’이라 불림

## 4.1.3 속성

- 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보

## 4.1.4 도메인

- 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합

## 4.1.5 필드와 레코드

![](https://velog.velcdn.com/images/cxxxtxxyxx/post/ac48a50a-c6a9-4298-a7de-68c2b48de3a5/image.png)

## 4.1.6 관계

![](https://blog.kakaocdn.net/dn/kCnHv/btqLW8LRGpN/IDARbgYYD5WmA7wfo7m2y1/img.gif)

### 1:1 관계

- 테이블을 두 개의 테이블로 나눠 테이블의 구조를 더 이해하기 쉽게 만들어줌

### 1:N 관계

- 한 개체가 다른 많은 개체를 포함하는 관계

### M:N 관계

- 테이블 두 개를 직접적으로 연결해서 구축하지는 않고, 1:N, 1:M이라는 관계를 갖는 테이블 두 개로 나눠서 설정

## 4.1.7 키

![](https://velog.velcdn.com/images/narangke3/post/8501f08c-f8b4-4e62-b91a-9aa0fba042a2/image.png)

### 기본키

- 유일성과 최소성을 만족하는 키

### 외래키

- 다른 테이블의 기본키를 그대로 참조하는 값으로 개체와의 관계를 식별하는데 사용

### 후보키

- 기본키가 될 수 있는 후보들이며 유일성과 최소성을 동시에 만족하는 키

### 대체키

- 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키

### 슈퍼키

- 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키

---

# 4.2 ERD와 정규화 과정

- ERD는 DB를 구축할 때 가장 기초적인 뼈대 역할을 하며 릴레이션 간의 관계들을 정의한 것

## 4.2.1 ERD의 중요성

- ERD는 시스템의 요구 사항을 기반으로 작성되며 이 ERD를 기반으로 DB를 구축
- 구축 이후에도 디버깅 또는 비즈니스 프로세스 재설계가 필요한 경우 설계도 역할을 담당
- 비정형 데이터는 충분히 표현할 수 없는 단점이 있음

## 4.2.3 정규화 과정

- 릴레이션 간의 잘못된 종속 관계로 인해 DB 이상 현상이 일어나 이를 해결하거나 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정
- DB 이상 현상: 회원이 한개의 등급을 가져야 하는데 세 개의 등급을 갖거나 삭제할 때 필요한 데이터가 같이 삭제되고 데이터를 삽입해야 하는데 하나의 필드 값이 NULL이 되면 안되어 삽입하기 어려운 현상들

### 정규형 원칙

- 같은 의미를 표현하는 릴레이션이지만 더 좋은 구조로 만들어야 하고, 자료의 중복성을 감소해야 하고, 독립적인 관계는 별개의 릴레이션으로 표현해야 하며, 각각 릴레이션은 독립적인 표현이 가능해야 하는 것

### 제1정규형

- 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자값만으로 구성되어야 하는 것
- 릴레이션의 속성 값 중 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안됨

### 제2정규형

- 릴레이션이 제1정규형이며 부분 함수의 종속성을 제거한 형태를 말함
- 부분 함수의 종석성 제거: 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것을 말함

### 제3정규형

- 제2정규형이고 기본키가 아닌 모든 속서이 이행적 함수 종속을 만족하지 않는 상태

이행적 함수 종속: A→B와 B→C가 존재하면 논리적으로 A→C가 성립되는데 이 때 집합 C가 집합 A에 이행적으로 함수 종속이 되었다고 함

### 보이스/코드 정규형

- 제3정규형이고 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태를 말함

---

# 4.3 트랜잭션과 무결성

## 4.3.1 트랜잭션

- DB에서 하나의 논리적 기능을 수행하기 위한 작업의 단위를 말하며 DB에 접근하는 방법은 쿼리이므로 여러 개의 쿼리들을 하나로 묶는 단위를 말함

### 원자성

- 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징
- 커밋과 롤백
    - 커밋: 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어, 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장되는 것을 말함
    - 롤백: 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 취소하는 일을 말함

### 일관성

- 허용된 방식으로만 데이터를 변경해야 하는 것을 의미

### 격리성

- 트랜잭션 수행 시 서로 끼어들지 못하는 것을 말함

### 지속성

- 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것을 의미
- DB에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 함

## 4.3.2 무결성

- 데이터의 정확성, 일관성, 유효성을 유지하는 것을 말하며 무결성이 유지되어야 하는 것
- 무결성 종류
    1. 개체 무결성: 기본키로 선택된 필드는 빈 값을 허용하지 않음
    2. 참조 무결성: 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 함
    3. 고유 무결성: 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가짐
    4. NULL 무결성: 특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다는 제약 조건

---

# 4.4 데이터베이스의 종류

## 4.4.1 관계형 데이터베이스

- RDBMS는 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 DB를 가리키며 SQL이란 언어를 써 조작
- MYSQL, PostgreSQL 등이 있음

## 4.4.2 NoSQL 데이터베이스

- SQL을 사용하지 않는 DB를 말함
- MongoDB, redis 등이 있음

---

# 4.5 인덱스

## 4.5.1 인덱스의 필요성

- 데이터를 빠르게 찾을 수 있는 하나의 장치

## 4.5.2 B-트리

[https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRSf_ZcUIx6klxXTUbBRq_cswKzHv-uiO477w&s](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRSf_ZcUIx6klxXTUbBRq_cswKzHv-uiO477w&s)

- 트리 탐색은 루트 노드부터 탐색이 일어나며 브랜치 노드를 거쳐 리프 노드까지 내려옴

### 인덱스가 효율적인 이유와 대수확장성

- 인덱스가 효율적인 이유: 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성 때문
- 대수확장성: 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것

## 4.5.4 인덱스 최적화 기법

1. 인덱스는 비용이다
2. 항상 테스팅하라
3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다

---

# 4.6 조인의 종류

- 조인이란 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것

![](https://blog.kakaocdn.net/dn/bUifb6/btsnSXyEyqK/68N37GEjEEnvK9yQiSfGM0/img.jpg)

## 4.6.1 내부 조인

- 내부 조인은 두 테이블 간에 교집합을 나태냄

```python
SELECT * FROM TableA A
INNER JOIN TableB B ON
A.key = B.key
```

## 4.6.2 왼쪽 조인

- 테이블 B의 일치하는 부분의 레코드와 함께 테이블 A를 기준으로 완전한 레코드 집합을 생성
- 테이블 B에 일치하는 항목이 없으면 해당 값은 null 값이 됨

```python
SELECT * FROM TableA A
LEFT JOIN TableB B ON
A.key = B.key
```

## 4.6.3 오른쪽 조인

- 테이블 A에서 일치하는 부분의 레코드와 함께 테이블 B를 기준으로 완전한 레코드 집합을 생성
- 테이블 A에 일치하는 항목이 없으면 해당 값은 null 값이 됨

```python
SELECT * FROM TableA A
RIGHT JOIN TableB B ON
A.key = B.key
```

## 4.6.4 합집합 조인

- 양쪽 테이블에서 일치하는 레코드와 함께 테이블 A와 테이블 B의 모든 레코드 집합을 생성
- 일치하는 항목이 없으면 누락된 쪽에 null 값이 포함되어 출력

```python
SELECT * FROM TableA A
FULL OUTER JOIN TableB B ON
A.key = B.key
```

---

# 4.7 조인의 원리

## 4.7.1 중첩 루프 조인

- 중첩 for문과 같은 원리로 조건에 맞는 조인을 하는 방법
- 랜덤 접근에 대한 비용이 많이 증가하므로 대용량의 테이블에서는 사용하지 않음

## 4.7.2 정렬 병합 조인

- 각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인
- 조인할 때 쓸 적절한 인덱스가 없고 대용량의 테이블들을 조인하고 조인 조건으로 <,> 등 범위 비교 연산자가 있을 때 사용

## 4.7.3 해시 조인

- 해시 테이블을 기반으로 조인하는 방법
- 두 개의 테이블을 조인한다고 했을 때 하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율적

---

[면접 질문](https://www.notion.so/1ef9bf2d261a80fcb6d3ce8f55c1cb74?pvs=21)