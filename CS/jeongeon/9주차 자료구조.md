# 5. 자료구조

# 5.1 복잡도

## 5.1.1 시간 복잡도

- 시간 복잡도란 입력 크기에 대해 어떠한 알고리즘이 실행되는데 걸리는 시간
- 주요 로직의 반복 회수를 중점으로 측정

### 빅오 표기법

- 입력 범위 n을 기준으로 로직이 몇 번 반복 되는지 나타내는 것
- 가장 영향을 많이 끼치는 항의 상수 인자를 빼고 나머지 항을 없앤 것
- 입력 크기가 커질수록 연산량이 가장 많이 커지는 항은 n의 제곱항이고, 다른 것은 그에 비해 미미해 이것만 신경쓰면 된다는 이론

 

### 시간 복잡도의 존재 이유

- 효율적인 코드로 개선하는 데 쓰이는 척도가 됨

### 시간 복잡도의 속도 비교

![](https://velog.velcdn.com/images/doriskim/post/1b7079a4-dc14-486e-a1e5-e3368f40a7a2/image.png)

- O(1)을 지향해야함

## 5.1.2 공간 복잡도

- 공간 복잡도는 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양
- 정적 변수로 선언된 것 말고도 동적으로 재귀적인 함수로 인해 공간을 계속해서 필요로 할 경우도 포함

## 5.1.3 자료 구조에서의 시간 복잡도

- 자료 구조를 쓸 때는 시간 복잡도를 잘 생각해야 함

![](https://velog.velcdn.com/images/ejung803/post/5ec7c9a6-8072-4d4d-a906-0c26e400eee7/image.png)

---

# 5.2 선형 자료 구조

- 요소가 일렬로 나열되어 있는 자료 구조를 말함

## 5.2.1 연결 리스트

- 데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화 시킨 자료 구조
- 삽입과 삭제가 O(1)이 걸리고 탐색에는 O(n)이 걸림
1. 싱글 연결 리스트: next 포인터만 가짐
2. 이중 연결 리스트: next 포인터와 prev 포인터를 가짐
3. 원형 이중 연결 리스트: 이중 연결 리스트와 같지만 마지막 노드의 next 포인터가 헤드 노드를 가리키는 것을 말함

## 5.2.2 배열

- 같은 타입의 변수들로 이루어져 있고 크기가 정해져 있으며 인접한 메모리 위치에 있는 데이터를 모아놓은 집합, 중복을 허용하고 순서가 있음
- 접근에 O(1)이고 랜덤 접근이 가능, 삽입과 삭제에는 O(n)이 걸림
- 데이터 추가와 삭제를 많이 하는 것은 연결 리스트, 접근(참조)를 많이 하는 것은 배열로 하는 것이 좋음

### 랜덤 접근과 순차적 접근

- 동일한 시간에 배열과 같은 순차적 데이터가 있을 때 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능
- 순차적 접근은 데이터가 저장된 순서대로 검색해야 함

### 배열과 연결 리스트 비교

- 배열은 상자를 순서대로 나열한 데이터 구조, 몇 번째 상자인지만 알면 해당 상자 요소를 꺼낼 수 있음
- 연결 리스트는 상자를 선을 연결한 형태의 데이터 구조, 상자 안 요소를 알기위해선 하나씩 상자 내부를 확인해봐야 함
- n번째 요소 접근에는 배열은 O(1), 연결 리스트는  O(n)의 시간 복잡도를 가짐
- 데이터 추가 및 삭제는 배열보다 연결 리스트가 더 빠름

## 5.2.3 벡터

- 동적으로 요소를 할당할 수 있는 동적 배열, 컴파일 시점에 개수를 모른다면 벡터를 써야 함
- 중복을 허용하고 순서가 있고 랜덤 접근이 가능
- 탐색과 맨 뒤의 요소를 삭제, 삽입하는데 O(1)이 걸리며 맨 뒤가 아닌 요소를 삭제,삽입 하는데 O(n)이 걸림

## 5.2.4 스택

- 스택은 가장 마지막으로 들어간 데이터가 가장 첫번째로 나오는 성질을 가진 자료 구조
- 삽입,삭제에 O(1), 탐색에 O(n)이 걸림

## 5.2.5 큐

- 먼저 집어넣은 데이터가 먼저 나오는 성질을 지닌 자료구조, 스택과 반대되는 개념
- 삽입,삭제에 O(1) 탐색에 O(n)이 걸림

---

# 5.3 비선형 자료 구조

- 비선형 자료 구조란 일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조를 말함

## 5.3.1 그래프

- 정점과 간선으로 이루어진 자료 구조

### 정점과 간선

- ‘어떠한 곳’에서 ‘어떠한 곳’으로 ‘무언가’를 통해 간다 했을 때 ‘어떠한 곳’은 정점, ‘무언가’는 간선이 됨
1. 단방향 간선: 한곳만 이어진 간선
2. 양방향 간선: 양쪽으로 이어진 간선
- outdegree: 정점으로 나가는 간선
- indegree: 정점으로 들어오는 간선

가중치

- 간선과 정점 사이에 드는 비용

## 5.3.2 트리

- 그래프의 특징처럼 정점과 간선으로 이루어져 있고, 트리 구조로 배열된 일종의 계층적 데이터의 집합
- 루트 노드, 내부 노드, 리프 노드 등으로 구성됨

### 트리의 특징

![](https://mblogthumb-phinf.pstatic.net/MjAyMjA0MTdfMTcg/MDAxNjUwMjA2NDIyMzE0.dUkVRV2xFS5Z9CgBvtcoOnfttt5YrpTWos7HW3-nJUkg.umvBcD_mGg7KkQ2XXDCHEXTBnicMenmyHjKWrg1-FHcg.JPEG.jhc9639/24.JPG?type=w800)

- V - 1 = E, 간선 수는 노드 수 -1임
- 임의의 두 노드 사이의 경로는 유일무이하게 존재함, 트리 내의 어떤 노드와 어떤 노드까지의 경로는 반드시 있음

### 트리의 구성

- 루트 노드: 가장 위에 있는 노드
- 내부 노드: 루트 노드와 리프 노드 사이에 있는 노드
- 리프 노드: 리프 노드는 자식 노드가 없는 노드를 뜻함

### 트리의 높이와 레벨

![](https://mblogthumb-phinf.pstatic.net/MjAyMjA0MTdfMTQg/MDAxNjUwMjA2NDk5ODg4.80rBsRUuPP9hijE-G_iFvnMD46CH1VDRIf7lIq7WnlAg.hfcK5_APqsG4qKWtX6TOONXcihgDWRAQhUym-Bwz2yog.JPEG.jhc9639/132.JPG?type=w800)

- 깊이: 루트 노드부터 특정 노드까지 최단 거리로 갔을 때의 거리
- 높이: 루트 노드부터 리프 노드까지 거리 중 가장 긴 거리
- 레벨: 1번 노드를 0레벨이라하면 2,3번 노드는 1레벨, 이런 식으로 나아가는 것
- 서브트리: 트리 내의 하위 집합, 트리 내에 있는 부분집합

### 이진 트리

- 자식의 노드 수가 두 개 이하인 트리를 의미

![](https://velog.velcdn.com/images/dlgosla/post/88dd094e-4ff4-482b-999e-f59771c0e890/image.png)

- 정이진 트리(Full Binary tree): 자식 노드가 0 또는 두 개인 이진 트리를 의미
- 완전 이진 트리(Complete Binary Tree): 왼쪽에서부터 채워져 있는 이진 트리를 의미
- 변질 이진 트리(Degenerate Binary Tree): 자식 노드가 하나밖에 없는 이진 트리
- 포화 이진 트리(Perfect Binary Tree): 모든 노드가 꽉 차 있는 이진 트리
- 균형 이진 트리(Balanced Binary Tree): 왼쪽과 오른쪽 노드의 높이 차이가 1 이하인 이진 트리

### 이진 탐색 트리

- 노드의 오른쪽 하위 트리에는 ‘노드 값보다 큰 값’이 있는 노드만 포함되고, 왼쪽 하위 트리에는 ‘노드 값보다 작은 값’이 들어 있는 트리를 말함
- 요소를 찾을 때 O(logn)이 걸림, 최악의 경우 O(n)이 걸림

 

### AVL 트리

- 선형적인 트리가 되는 것을 방지하고 스스로 균형을 잡는 이진 탐색 트리
- 두 자식 서브트리의 높이는 항상 최대 1만큼 차이 난다는 특징이 있음

### 레드 블랙 트리

- 균형 이진 탐색 트리로 탐색, 삽입, 삭제 모두 시간 복잡도가 O(logn)임
- 각 노드는 빨간색 또는 검은색의 색상을 나타내는 추가 비트를 저장하며, 삽입 및 삭제 중에 트리가 균형을 유지하도록 사용됨

## 5.3.3 힙

- 완전 이진 트리 기반의 자료 구조, 최소힙과 최대힙 두 가지가 있고 해당 힙에 따라 특정한 특징을 지킨 트리를 말함
- 최대힙:  루트 노드에 있는 키는 모든 자식에 있는 키 중 가장 커야 함, 각 노드의 자식 노드와의 관계도 이와 같은 특징이 재귀적으로 이루어져야 함
- 최소힙: 최소힙에서 루트 노드에 있는 키는 모든 자식에 있는 키 중 최솟값이어야 함, 각 노드의 자식 노드와의 관계도 이와 같은 특징이 재귀적으로 이루어져야 함

### 최대힙의 삽입

- 힙에 새로운 요소가 들어오면, 새로운 노드를 힙의 마지막 노드에 이어서 삽입함
- 새로운 노드를 부모 노드들과의 크기를 비교하며 교환해서 힙의 성질을 만족시킴

### 최대힙의 삭제

- 최대힙에서 최댓값은 루트 노드이므로 루트 노드가 삭제되고 그 이후 마지막 노드와 루트 노드를 스왑하여 또다시 스왑 등의 과정을 거쳐 재구성됨

## 5.3.4 우선순위 큐

- 우선순위 대기열이라고도 하며, 대기열에서 우선순위가 높은 요소가 우선순위가 낮은 요소보다 먼저 제공되는 자료 구조

## 5.3.5 맵

- 맵은 특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료 구조

## 5.3.6 셋

- 셋은 특정 순서에 따라 고유한 요소를 저장하는 컨테이너, 중복되는 요소는 없고 오로지 희소한 값만 저장하는 자료 구조

## 5.3.7 해시 테이블

- 무한에 가까운 데이터들을 유한한 개수의 해시 값으로 매핑한 테이블
- 삽입, 삭제, 탐색 시 평균적으로 O(1)의 시간복잡도를 가짐