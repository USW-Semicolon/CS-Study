# 3.운영체제

- 사용자가 컴퓨터를 쉽게 다루게 해주는 인터페이스, 한정된 메모리나 시스템 자원을 효율적으로 분배해줌

---

# 3.1 운영체제와 컴퓨터

## 3.1.1 운영체제의 역할과 구조

### 운영체제 역할

1. CPU 스케줄링과 프로세스 관리: :CPU 소유권을 어떤 프로세스에 할당할지, 프로세스의 생성과 삭제, 자원 할당 및 반환 관리
2. 메모리 관리: 한정된 메모리를 어떤 프로세스에 얼마큼 할당해야 하는지 관리
3. 디스크 파일 관리
4. I/O 디바이스 관리: 마우스, 키보드와 컴퓨터 간 데이터를 주고받는 것을 관리

### 운영체제의 구조

[https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQBdrunNCzea_MIbKYLCF2DgXPuy0OobA5LpA&s](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQBdrunNCzea_MIbKYLCF2DgXPuy0OobA5LpA&s)

-GUI, 시스템콜, 커널, 드라이버 부분까지 운영체제 부분

### 시스템 콜

- 운영체제가 커널에 접근하기 위한 인터페이스
- 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 사용
- 프로세스나 스레드에서 운영체제로 어떠한 요청을 할 때 시스템콜과 커널을 거쳐 운영체제에 전달됨

modeit
- 1 또는 0의ㅣ 값을 가지는 플래그 변수
- modeit의 0은 커널모드, 1은 유저모드

---

 

## 3.1.2 컴퓨터의 요소

- 컴퓨터는 CPU, DMA 컨트롤러, 메모리, 타이머, 디바이스 컨트롤러 등으로 이루어져 있음

### CPU

- 산술논리연산장치, 제어장치, 레지스터로 구성되어 있는 컴퓨터 장치
- 인터럽트에 의해 단순히 메모리에 존재하는 명령어를 해석해서 실행하는 일꾼
- 관리자 역할을 하는 운영체제의 커널이 프로그램을 메모리에 올려 프로세스를 만들면 CPU가 이를 처리

제어장치

- 프로세스 조작을 지시하는 CPU의 부품
- 입출력장치 간 통신을 제어하고 명령어들을 읽고 해석하며 데이터 처리를 위한 순서를 결정

레지스터

- CPU 안에 있는 매우 빠른 임시기억장치
- 연산속도가 메모리보다 수백 빼까지 빠름

산술논리연산장치

- 덧셈, 뺄셈 등 산술 연산과 논리합, 논리곱 같은 논리 연산을 계산하는 디지털 회로

- CPU의 연산 처리
    
    ![](https://blog.kakaocdn.net/dn/Zt19O/btrWIyr0n7e/ijMkEV25taOuRot5PdoqJk/img.png)
    
    1. 제어장치가 메모리에 계산할 값을 로드, 또한 레지스터에도 로드
    2. 제어장치가 레지스터에 있는 값을 계산하라고 산술논리연산장치에 명령
    3. 제어장치가 계산된 값을 다시 레지스터에서 메모리로 계산한 값을 저장

인터럽트

- 어떤 신호가 들어왔을때 CPU를 잠깐 정지시키는 것
- 인터럽트가 발생되면 인터럽트 핸들러 함수가 모여 있는 인터럽트 벡터로 가서 인터럽트 핸들러 함수가 실햄됨
- 인터럽트 간 우선순위에 따라 실행됨

하드웨어 인터럽트

- 키보드나 마우스를 연결하는 등 IO 디바이스에서 발생하는 인터럽트
- 인터럽트 라인이 설계된 이후 순차적인 인터럽트 실행을 중지하고 운영체제에 시스템콜을 요청해서 원하는 디바이스로 향해 디바이스에 있는 작은 로컬 버퍼에 접근하여 일을 수행

소프트웨어 인터럽트

- 트랩 (trap)이라고도 함. 프로세스 오류 등으로 프로세스가 시스템콜을 호출할 때 발동

### DMA 컨트롤러

- I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치

### 메모리

- 데이터나 상태, 명령어 등을 기록하는 장치, 보통 RAM을 일컬어 메모리라고 함
- CPU는 계산을 담당하고, 메모리는 기억을 담당함

### 타이머

- 몇 초 안에는 작업이 끝나야 한다는 것을 정하고 특정 프로그램에 시간 제한을 다는 역할을 함
- 시간이 많이 걸리는 프로그램이 작동할 때 제한을 걸기 위해 존재

### 디바이스 컨트롤러

- 컴퓨터와 연결되어 있는 IO 다비이스들의 작은 CPU를 말함
- 옆에 붙어 있는 로컬 버퍼는 각 디바이스에서 데이터를 임시로 저장하기 위한 작은 메모리를 뜻함

---

# 3.2 메모리

## 3.2.1 메모리 계층

- 메모리 게층은 레지스터, 캐시, 저장장치로 구성

[https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F996B92345BE2467F31](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F996B92345BE2467F31)

1. 레지스터: CPU 안에 있는 작은 메모리, 휘발성, 가장 빠른 속도, 기억용량이 가장 적음
2. 캐시: L1, L2, L3 캐시를 지칭, 휘발성, 속도 빠름, 기억 용량이 적음
3. 주기억장치: RAM을 가리킴, 휘발성, 속도 보통, 기억 용량이 보통
4. 보조기억장치: HDD, SSD 지칭, 비휘발성, 속도 낮음, 기억 용량 많음

### 캐시

- 데이터를 미리 복사해 놓는 임시 저장소이자 삐른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리
- 메모리와 CPU 간 속도 차이가 너무 크기에 중간에 레지스터 계층을 둬 속도 차이 해결

- 지역성의 원리
    
    시간 지역성
    
    - 최근 사용한 데이터에 다시 접근하려는 특성
    
    공간 지역성
    
    - 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성

캐시히트와 캐시미스

- 캐시에서 원하는 데이터를 찾으면 캐시히트, 찾지 못하면 캐시미스

[https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSN6Y7dgTVlXAvmPodq1e6AzPyf3zGytbugBQ&s](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSN6Y7dgTVlXAvmPodq1e6AzPyf3zGytbugBQ&s)

- 캐시히트의 경우 위치도 가깝고 CPU 내부 버스를 기반으로 작동해 빠름
- 캐시미스가 발생되면 메모리에서 데이터를 가져오는데 시스템 버스 기반으로 작동해 느림

- 캐시매핑
    - 캐시가 히트되기 위해 매핑하는 방법
    - 캐시매핑 분류
        1. 직접 매핑: 메모리가 1~100이 있고, 캐시가 1~10이 있다면 1:1~10, 2:1~20 이런 식으로 매핑. 처리가 빠르지만 충돌 발생이 잦음
        2. 연관 매핑: 순서를 일치시키지 않고 관련 있는 캐시와 메모리를 매핑. 충돌이 적지만 모든 블록을 탐색해야해서 속도가 느림
        3. 집합 연관 매핑: 직접 매핑과 연관 매핑을 합쳐 놓은 것. 순서는 일치시키지만 집합을 둬서 저장하며 블록화되어 있기 때문에 검색은 좀 더 효율적.

- 웹 브라우저의 캐시
    - 사용자의 커스텀한 정보나 인증 모듈 관련 사항들을 웹 브라우저에 저장해 추후 서버에 요청할 때 자신을 나타내는 아이덴티티나 중복 요청 방지를 위해 쓰이며 오리진 (origin)에 종속
    1. 쿠키
    2. 로컬 스토리지
    3. 세션 스토리지

- 데이터베이스의 캐싱 계층
    - DB 시스템을 구축할 때도 메인 DB 위에 레디스(redis) DB 계층을 캐싱 계층으로 둬 성능을 향상 시키기도 함

---

## 3.2.2 메모리 관리

### 가상 메모리

- 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화해 사용자들에게 매우 큰 메모리로 보이게 만드는 것

![](https://velog.velcdn.com/images/gkqls813/post/a67ec0ef-1580-4bce-a154-89b2a1a5386e/image.png)

- 가상 주소(Logical Address): 가상적으로 주어진 주소
- 실제 주소(Physical Address): 실제 메모리상에 있는 주소
- 가상 주소는 메모리관리장치(MMU)에 의해 실제 주소로 변환되어 사용자는 실제 주소를 의식할 필요 없이 프로그램을 구축할 수 있음
- 가상 메모리는  가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어있는 ‘페이지 테이블’로 관리됨

스와핑

- 가상 메모리에는 존재하지만 RAM에는 현재 없는 데이터나 코드에 접근할 경우 페이지 폴트 발생
- 이때 메모리에서 당장 사용하지 않을 영역을 HDD로 옮기고 HDD의 일부분을 마치 메모리처럼 불러와 쓴는 것을 말함

페이지 폴트

- 프로세스의 주소 공간에는 존재하지만 RAM에는 없는 데이터에 접근했을 경우 발생
- 페이지 폴트로 인한 스와핑 과정
    1. 어떤 명령어가 유효한 가상 주소에 접근했으나 해당 페이지가 만약 없다면 트랩(trap)이 발생되어 운영체제에 알림
    2. 운영체제는 실제 디스크로부터 사용하지 않은 프레임을 찾음
    3. 해당 프레임을 실제 메모리에 가져와 페이지 교체 알고리즘을 바탕으로 특정 페이지와 교체(이때 스와핑 발생)
    4. 페이지 테이블을 갱신시킨 후 해당 명령어를 다시 시작

### 스레싱

- 메모리의 페이지 폴트율이 높은 것을 의미, 컴퓨터의 심각한 성능 저하를 초래
- 메모리에 너무 많은 프로세스가 동시에 올라가면 스와핑이 많이 일어나 발생, 페이지 폴트가 일어나면 CPU 이용률이 낮아지고 운영체제는 CPU 가용성을 높이기 위해 더 많은 프로세스를 올리면서 악순환 반복
- 해결방법으로 메모리를 늘리거나, HDD를 SDD로 바꾸기. 운영체제 해결방법은 작업세트와 PFF가 있음

작업세트

- 프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 만들어 미리 메모리에 로드하는 것
- 미리 로드하면 탐색 비용을 및 스와핑을 줄일 수 있음

PFF

- 페이지 폴트 빈도를 조절하는 방법으로 상한선과 하한선을 만듦
- 상한선에 도달하면 프레임을 늘리고 하한선에 도달하면 프레임을 줄임

### 메모리 할당

- 연속 할당
    - 메모리에 연속적으로 공간을 할당하는 것
    
    ![](https://velog.velcdn.com/images/gkqls813/post/71ca5498-6140-40fb-9464-f0dea16e0218/image.png)
    
    - 고정 분할 방식
        - 메모리를 미리 나누어 관리하는 방식,
        - 메모리가 미리 나뉘어 있어 융통성이 없고 내부 단편화가 발생
    - 가변 분할 방식
        - 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용
        - 내부 단편화는 발생하지 않고, 외부 단편화는 발생
        - 가변 분할 방식 종류
            
            최초적합: 위쪽이나 아래쪽부터 시작해 홀을 찾으면 바로 할당
            
            최적적합: 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당
            
            최악적합: 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당
            
- 불연속 할당
    - 메모리를 연속적으로 할당하지 않는 것
    
    페이징
    
    - 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당
    
    세그멘테이션
    
    - 페이지 단위가 아닌 의미 단위인 세그먼틀 나누는 방식
    
    페이지드 세그멘테이션
    
    - 프로글매을 의미 단위인 세그먼트로 나눠 공유나 보안 측면에 가점을 두고 임의의 길이가 아닌 동일한 크기의 페이지 단위로 나누는 것

### 페이지 교체 알고리즘

- 페이지 교체 알고리즘 기반으로 스와핑이 일어남

오프라인 알고리즘

- 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘
- 하지만 미래에 사용되는 프로세스를 예측할 수 없어 사용할 수 없는 알고리즘

FIFO (First In First Out)

- 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법을 의미

LRU (Least Recently Used)

- 참조가 가장 오래된 페이지를 바꿈
- 오래된 것을 파악하기 위해 각 페이지마다 계수기, 스택을 두어야 하는 문제점이 있음

---

## 3.3 프로세스와 스레드

- 프로세스: 컴퓨터에서 실행되고 있는 프로그램, 프로그램이 메모리에 올라가 인스턴스화 된 것
- 스레드: 프로세스 내 작업의 흐름

### 3.3.1 프로세스와 컴파일 과정

![](https://velog.velcdn.com/images/maantano/post/f0946e57-ba00-40bc-be55-aa8a8cb82cd4/image.png)

### 전처리

- 소스 코드의 주석을 제거하고 #include 등 헤더 파일을 병합하여 매크로로 치환

### 컴파일러

- 오류 처리, 코드 최적화 작업을 하며 어셈블리어로 변환

### 어셈블러

- 어셈블리어는 목적 코드로 변환됨. 확장자는 운영체제마다 상이

### 링커

- 프로그램 내에 있는 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합하여 실행 파일 만듦

정적 라이브러리

- 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는 방식으로 라이브러리를 쓰는 방법
- 시스템 환경 등 외부 의존도가 낮은 장점이 있지만 코드 중복 등 메모리 효율성이 떨어짐

동적 라이브러리

- 프로그램 실행 시 필요할 때만 DDL이라는 함수 정보를 통해 참조하여 라이브러리를 쓰는 방법
- 메모리 효울성에 장점이 있지만 외부 의존도가 높아진다는 단점이 있음

---

## 3.3.2 프로세스의 상태

### 생성상태

- 프로세스가 생성된 상태를 의미하며 fork(), exec() 함수를 통해 생성. 이때 PCB가 할당

fork()

- 부모 프로세스의 주소 공간을 그대로 복사, 새로운 자식 프로세스를 생성하는 함수

exec()

- 새롭게 프로세스를 생성하는 함수

### 대기상태

- 메모리 공간이 충분하면 메모리를 할당받고 아니면 아닌 상태로 대기하고 있으며 cpu 스케줄러로부터 cpu 소유권이 넘어오기를 기다리는 상태

### 대기 중단 상태

- 메모리 부족으로 일시 중단된 상태

### 실행 상태

- cpu 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태를 의미

### 중단 상태

- 어떤 이벤트가 발생한 후 기다리며 프로세스가 차단된 상태

### 일시 중단 상태

- 중단된 상태에서 프로세스가 실행되려 했지만 메모리 부족으로 일시 중단된 상태

### 종료 상태

- 메모리와 cpu 소유권을 모두 놓고 가는 상태

---

## 3.3.3 프로세스의 메모리 구조

![](https://velog.velcdn.com/images%2Fcchloe2311%2Fpost%2F9a74f36f-fc70-4292-8302-9884f9826987%2Fimage.png)

- 스택은 위 주소부터, 힙은 아래 주소부터 할당 됨

### 스택과 힙

- 스택과 힙은 동적 할당이 됨, 동적할당은 런타임 단계에서 메모리를 할당받는 것을 말함
- 스택은 지역변수, 매개변수, 실행되는 함수에 의해 늘어들거나 줄어드는 메모리 영역
- 힙은 동적으로 할당되는 변수들을 담음, malloc(), free()함수를 통해 관리되며 동적으로 관리되는 자료 구조의 경우 힙 영역을 사용

### 데이터 영역과 코드 영역

- 정적 할당되는 영역, 정적 할당은 컴파일 단계에서 메모리를 할당하는 것
- 데이터 영역은 BSS segment, Data segment, code/text segment로 나뉘어 저장됨
    - BSS segment
        - 전역 변수 또는 static, const로 선언되어 있고 0으로 초기화 또는 초기화가 어떠한 값으로도 되어 있지 않은 변수들이 이 메모리 영역에 할당됨
    - Data segment
        - 전역 변수 또는 static, const로 선언되어 있고 0이 아닌 값으로 초기화된 변수가 할당됨
    - code segment
        - 프로그램의 코드가 들어감

---

## 3.3.4 PCB

- 운영체제에서 프로세스에 대한 메타데이터를 저장한 데이터를 말함
- 프로그램이 실행되면 프로세스가 생성되고 프로세스 주소 값들에 스택, 힙 등의 구조를 기반으로 메모리가 할당되는데 이 프로세스의 메타데이터들의 PCB에 저장되어 관리됨

### PCB의 구조

- 프로세스 스케줄링 상태: 준비, 일시중단 등 프로세스가 CPU에 대한 소유권을 얻은 이후의 상태
- 프로세스 ID: 프로세스 ID, 해당 프로세스의 자식 프로세스 ID
- 프로세스 권한: 컴퓨터 자원 또는 I/O 디바이스에 대한 권한 정보
- 프로그램 카운터: 다음 명령어의 주소에 대한 포인터
- CPU 레지스터: 저장해야 할 레지스터에 대한 정보
- CPU 스케줄링 정보: 중단된 시간 등에 대한 정보
- 계정 정보: 실행에 사용된 CPU 사용량, 실행한 유저의 정보
- I/O 상태 정보: 할당된 I/O 디바이스 목록

### 컨텍스트 스위칭

- PCB를 기반으로 프로세스의 상태를 저장하고 로드시키는 과정
- 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생

---

## 3.3.5 멀티플로세싱

- 여러 개의 프로세스 즉 멀티프로세스를 통해 동시에 두가지 이상의 일을 수행할 수 있는 것을 의미

---

## 3.3.6 스레드와 멀티스레딩

### 스레드

- 프로세스의 실행 가능한 가장 작은 단위, 프로세스는 여러 스레드를 가질 수 있음

### 멀티스레딩

- 프로세스 내 작업을 여러 개의 스레드로 처리하는 기법이며 스레드끼리 서로 자원을 공유하기 때문에 효율성이 높음

---

## 3.3.7 공유 자원과 임계 영역

### 공유자원

- 시스템 안에서 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터 등의 자원이나 변수 등을 의미
- 경쟁 상태: 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황

### 임계 영역

- 둘 이상의 프로세스, 스레드가 공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드 영역을 말함
- 임계 영역을 해결한는 방법은 뮤텍스, 세마포어, 모니터 세 가지가 있음
    - 뮤텍스
    -프로세스나 스레드가 공유 자원을 lock()을 통해 잠금 설정하고 사용한 후 unlock()을 통해 잠금 해제하는 객체
    - 세마포어
    -일반화된 뮤텍스, 간단한 정수 값과 두 가지 함수 wait 및 signal로 공유 자원에 대한 접근을 처리
    - 모니터
    -둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공

---

## 3.3.8 교착 상태

- 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태
- 교착 상태 원인
    - 상호 배제: 한 프로세스가 자원을 독점하고 있으면 다른 프로세스들은 접근이 불가함
    - 점유 대기: 특정 프로세스가 점유한 자원을 다른 프로세스가 요청한 상태
    - 비선점: 다른 프로세스의 자원을 강제적으로 가져올 수 없음
    - 환형 대기: A는 B의 자원을 요구하고, B는 A의 자원을 요구하는 서로가 서로의 자원을 원하는 상태
- 교착 상태 해결 방법
    1. 자원을 할당할 때 애초에 조건이 성립되지 않도록 설계
    2. 교착 상태 가능성이 없을 때만 자원 할당되며, 프로세스당 요청할 자원들의 최대치를 통해 자원 할당 가능 여부를 파악하는 은행원 알고리즘 사용
    3. 교착 상태가 발생하면 사이클이 있는지 찾아보고 관련된 프로세스를 한개 씩 지움
    4. 교착 상태가 발생하면 사용자가 작업을 종료

---