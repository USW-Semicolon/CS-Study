# 운영체제
---

## 운영체제의 역할과 구조

### 운영체제의 역할
> 운영체제(OS, Operating System)는 컴퓨터 자원을 효율적으로 관리하고 사용자 및 응용 프로그램이 하드웨어와 원활히 상호작용할 수 있도록 중재하는 소프트웨어이다.

1. **CPU 스케줄링과 프로세스 관리**  
   → 여러 프로세스가 CPU를 번갈아 사용할 수 있도록 관리  
   → 문맥 전환, 프로세스 상태 전이, 스케줄링 알고리즘 처리 포함

2. **메모리 관리**  
   → 물리 메모리를 각 프로세스에 적절히 분배  
   → 가상 메모리, 페이지 교체, 메모리 보호 등 포함

3. **디스크 파일 관리**  
   → 파일 저장, 접근 권한, 디렉토리 관리 등을 통해 저장장치의 자원을 효율적으로 운용

4. **I/O 디바이스 관리**  
   → 사용자 및 프로그램의 I/O 요청을 처리하고 디바이스와 연결하는 역할

### 운영체제의 구조

1. **유저 프로그램(User Program)**: 사용자 수준에서 실행되는 프로그램
2. **인터페이스(API/Shell)**: 사용자와 운영체제 간의 중간 인터페이스 (명령어 해석기 포함)
3. **시스템 콜(System Call)**: 커널 서비스를 유저 프로그램이 호출할 수 있는 창구
4. **커널(Kernel)**: 자원 관리의 핵심 부분으로, 하드웨어와 가장 밀접하게 동작
5. **하드웨어(Hardware)**: CPU, 메모리, 디스크, I/O 디바이스 등 물리 장치

#### 시스템 콜
> 운영체제가 제공하는 서비스에 접근하기 위한 **프로세스와 커널 간 인터페이스**

- 유저 모드에서 커널 모드로의 전환은 **트랩(Trap)** 이라는 특별한 인터럽트를 통해 발생
- 시스템 콜은 일반적으로 라이브러리 함수 형태로 제공됨 (`read()`, `write()`, `fork()` 등)
- 보안을 위해 커널만이 직접 하드웨어 접근을 허용, 유저는 시스템 콜을 통해 간접 접근

---

## 컴퓨터의 요소

- **CPU**: 명령어를 해석하고 실행하는 중앙처리장치
    - **제어장치**: 명령어 해석 및 실행 순서 제어
    - **레지스터**: CPU 내부의 초고속 메모리, 작업 상태 저장
    - **ALU**: 산술 및 논리 연산을 수행하는 연산 장치
    - **인터럽트**: 입출력, 예외, 시스템 호출 등 외부 요청에 의해 현재 작업을 중단하고 우선 처리

- **DMA 컨트롤러**: CPU를 거치지 않고 메모리와 I/O 장치 간 데이터를 직접 주고받게 해주는 하드웨어

- **메모리**: 실행 중인 프로그램과 데이터를 저장하는 공간

- **타이머**: 프로그램 실행 시간이 초과되었는지를 감시

- **디바이스 컨트롤러**: 각 I/O 장치와 운영체제를 연결하는 중재자 역할

---

## 메모리

### 메모리 계층

1. **레지스터**: CPU 내부, 가장 빠르지만 용량 적음
2. **캐시 메모리**: CPU와 RAM 사이의 중간 버퍼 (L1, L2, L3)
3. **주기억장치 (RAM)**: 실행 중인 프로그램 저장
4. **보조기억장치 (HDD, SSD)**: 영구 저장소

#### 캐시
- **지역성(Locality)** 기반으로 성능 향상
    - **시간 지역성**: 최근에 접근한 데이터에 다시 접근
    - **공간 지역성**: 인접한 주소 영역을 연속적으로 접근
- **캐시 매핑 방식**
    - 직접 매핑, 연관 매핑, 집합 연관 매핑 등

#### 캐시히트 & 캐시미스
- 캐시 히트: 캐시에 데이터가 있어 빠른 접근
- 캐시 미스: 데이터가 없어 RAM 등 느린 메모리에서 접근

---

### 메모리 관리

#### 가상 메모리
> 실제 물리 메모리보다 더 큰 주소 공간을 제공하는 기술

- 페이지 단위로 나눠 **주소 공간을 추상화**
- 프로세스는 자신만의 메모리 공간을 가지는 것처럼 동작

#### 스와핑
- 프로세스를 통째로 메모리와 디스크 간에 이동

#### 페이지 폴트
- 필요한 페이지가 메모리에 없는 경우 발생하는 예외 → 디스크에서 적재

#### 스레싱(Thrashing)
- 너무 많은 페이지 폴트로 인해 CPU가 **계속 메모리만 로딩**하는 상황
- **작업 세트(Working Set)**를 기반으로 발생 여부 판단
- **PFF (Page Fault Frequency)** 조절로 해결

#### 메모리 할당 방식

- **연속 할당**
    - **고정 분할**: 메모리를 일정 크기로 나눔 → 내부 단편화 발생
    - **가변 분할**: 필요에 따라 분할 → 외부 단편화 발생

- **불연속 할당**
    - **페이징(Paging)**: 페이지/프레임 단위로 물리/논리 주소 분리
    - **세그멘테이션(Segmentation)**: 논리적 단위(코드, 데이터 등)로 나눔
    - **페이지드 세그멘테이션**: 페이징 + 세그멘테이션 결합

---

## 프로세스와 스레드

### 프로세스와 컴파일 과정
- 전처리 → 컴파일러 → 어셈블러 → 링커
- 최종적으로 실행 가능한 바이너리(.exe 등) 생성

### 프로세스의 상태
- 생성, 준비, 실행, 대기, 종료, 일시 중단
- `fork()`로 복사, `exec()`로 새로운 프로그램 실행

### 프로세스의 메모리 구조
- **코드(Code)**: 실행 명령어
- **데이터(Data)**: 전역/정적 변수
- **힙(Heap)**: 동적 할당 메모리 영역
- **스택(Stack)**: 함수 호출, 지역 변수 저장

### PCB (Process Control Block)
- 프로세스의 상태 정보 저장 구조체
- 프로세스 ID, 레지스터 값, PC, 상태, 우선순위 등 포함

#### 컨텍스트 스위칭
- 실행 중인 프로세스 문맥을 저장하고, 다른 프로세스 문맥을 복원

---

### 멀티 프로세싱 & IPC

#### 멀티 프로세싱
- CPU 여러 개 사용 (대칭형, 비대칭형)
- 병렬 처리 성능 향상

#### IPC (프로세스 간 통신)
- 공유 메모리, 파이프, 메시지 큐, 소켓 등
- 자원 공유 또는 데이터 교환을 위해 사용

---

### 스레드와 멀티스레딩

#### 스레드
- 프로세스 내 실행 흐름 단위
- 자원 공유 (메모리, 파일 등), 경량화된 프로세스

#### 멀티스레딩
- 하나의 프로세스에서 여러 작업 동시 수행
- 컨텍스트 스위칭 비용 감소

---

### 임계 영역 & 동기화

#### 임계 영역
- 공유 자원 접근 시 발생할 수 있는 경쟁 조건 보호 영역

#### 동기화 도구
- **뮤텍스**: 상호 배제 보장
- **세마포어**: 자원 개수 제어 (바이너리/카운팅)
- **모니터**: 고급 동기화 추상화

---

### 교착 상태

#### 발생 조건 (Coffman)
1. 상호 배제
2. 점유와 대기
3. 비선점
4. 환형 대기

#### 해결 방법
- 예방: 조건 제거
- 회피: Banker's Algorithm
- 탐지 및 복구: 자원 할당 그래프 사용

---

## CPU 스케줄링

### 평가 기준
- CPU 이용률, 처리량, 대기 시간, 반환 시간, 응답 시간

### 비선점형
- **FCFS**: 먼저 온 순서대로 실행
- **SJF**: 실행 시간 짧은 순
- **우선순위**: 숫자가 낮을수록 우선 (기아 문제 발생 가능)

### 선점형
- **Round Robin**: 시간 할당량 기준 순환
- **SRTF**: 남은 시간이 짧은 순
- **다단계 큐**: 우선순위 큐 나누고 각기 다른 정책
- **다단계 피드백 큐**: 동적으로 우선순위 변경 가능, 현실적으로 많이 사용