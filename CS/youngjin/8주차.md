# 📘 자료구조 (Data Structure)

> 면접을 위한 핵심 CS 전공지식 요약 – 자료구조 (출처: 길벗, 주홍철)

---

## 1. 📊 복잡도 (Complexity)

### 1.1 시간 복잡도 (Time Complexity)

| 표기 | 의미 |
|------|------|
| O(1) | 입력 크기와 무관한 일정한 시간 (상수 시간) |
| O(log n) | 로그 시간, 이진 탐색 등에서 발생 |
| O(n) | 입력 크기만큼 순회 (선형 시간) |
| O(n log n) | 효율적인 정렬 알고리즘(병합정렬, 퀵정렬 평균 등) |
| O(n²) | 이중 반복문 (버블 정렬, 삽입 정렬 등) |
| O(2ⁿ) | 지수 시간, 모든 부분집합 탐색 등 |
| O(n!) | 순열 탐색 등 |

**💡 팁**: 시간 복잡도는 "최악의 경우(worst-case)"를 기준으로 면접에서 많이 질문함.

---

### 1.2 공간 복잡도 (Space Complexity)

- 알고리즘 수행 중 사용하는 **추가 메모리 공간**의 크기를 측정
- 예: 재귀 호출 시 스택 공간 사용 등
- 중요 고려 요소:
    - 입력 크기에 따라 사용하는 공간이 늘어나는가?
    - 별도의 자료구조를 사용하는가?

---

### 1.3 주요 자료구조의 시간 복잡도 비교

| 자료구조      | 접근 | 탐색 | 삽입 | 삭제 |
|--------------|------|------|------|------|
| 배열          | O(1) | O(n) | O(n) | O(n) |
| 연결 리스트   | O(n) | O(n) | O(1) | O(1) |
| 스택 / 큐     | O(n) | O(n) | O(1) | O(1) |
| 해시 테이블   | -    | O(1) | O(1) | O(1) |
| 이진 탐색 트리(BST) | O(log n) | O(log n) | O(log n) | O(log n) |
| 힙            | O(n) | O(n) | O(log n) | O(log n) |

---

## 2. 📦 선형 자료구조 (Linear Data Structures)

### 2.1 배열 (Array)
- 고정된 크기의 메모리 블록을 연속적으로 사용하는 자료구조
- **장점**: 인덱스를 이용한 빠른 접근 (O(1))
- **단점**: 크기 변경 어려움, 삽입/삭제 시 시간 소요

### 2.2 연결 리스트 (Linked List)

| 종류 | 특징 |
|------|------|
| 단일 연결 리스트 | 다음 노드만 참조 (forward only) |
| 이중 연결 리스트 | 이전/다음 노드를 모두 참조 (양방향) |
| 원형 연결 리스트 | 마지막 노드가 첫 노드를 참조 (순환 구조) |

- **장점**: 동적 메모리 할당으로 크기 유연
- **단점**: 임의 접근 느림 (O(n)), 포인터 관리 복잡

### 2.3 스택 (Stack)
- **LIFO(Last In, First Out)** 구조
- 사용 예: 괄호 검사, DFS, 재귀 함수 호출 스택
- 주요 연산:
    - `push()`: 삽입
    - `pop()`: 삭제
    - `peek()`: 최상단 요소 확인

### 2.4 큐 (Queue)
- **FIFO(First In, First Out)** 구조
- 사용 예: BFS, 프린터 큐, 운영체제의 작업 스케줄링
- 주요 연산:
    - `enqueue()`: 삽입
    - `dequeue()`: 삭제

> **파생 구조**
> - 원형 큐: 공간 활용 최적화
> - 우선순위 큐(Priority Queue): 우선순위 높은 요소가 먼저 나옴

### 2.5 벡터 (Vector)
- C++의 `std::vector`, Java의 `ArrayList`와 유사
- **자동 크기 조절**이 가능한 배열
- **장점**: 배열보다 유연함, 연속된 메모리로 인한 접근 속도 빠름

---

## 3. 🌲 비선형 자료구조 (Non-linear Data Structures)

### 3.1 트리 (Tree)

| 용어 | 설명 |
|------|------|
| 루트 (Root) | 최상단 노드 |
| 리프 (Leaf) | 자식이 없는 노드 |
| 높이 (Height) | 루트에서 리프까지의 최대 거리 |
| 깊이 (Depth) | 루트에서 특정 노드까지의 거리 |

- **이진 트리 (Binary Tree)**: 노드가 최대 2개의 자식을 가짐
- **이진 탐색 트리 (BST)**: 왼쪽 < 부모 < 오른쪽 규칙
- **트리 순회**
    - 전위 순회 (Preorder): Root → Left → Right
    - 중위 순회 (Inorder): Left → Root → Right
    - 후위 순회 (Postorder): Left → Right → Root

### 3.2 그래프 (Graph)

| 요소 | 설명 |
|------|------|
| 정점 (Vertex) | 노드 |
| 간선 (Edge) | 정점 간의 연결선 |
| 방향성 | 무방향 / 유방향 |
| 순환성 | 순환 / 비순환 |
| 표현 방법 | 인접 행렬 / 인접 리스트 |

- 탐색 알고리즘
    - **DFS** (깊이 우선 탐색)
    - **BFS** (너비 우선 탐색)

### 3.3 힙 (Heap)
- **완전 이진 트리 기반 자료구조**
- 우선순위 큐 구현에 사용
- **최대 힙 (Max Heap)**: 부모 ≥ 자식
- **최소 힙 (Min Heap)**: 부모 ≤ 자식
- 삽입/삭제 연산: O(log n)

### 3.4 우선순위 큐 (Priority Queue)
- 일반적인 큐와 달리 **우선순위 높은 데이터**가 먼저 나감
- 구현: 힙 기반으로 자주 구현됨

### 3.5 맵 (Map) / 셋 (Set)
- **Map (Dictionary)**: 키-값(Key-Value) 쌍 저장
- **Set**: 중복 없는 요소의 집합
- Java: `HashMap`, `HashSet`, C++: `unordered_map`, `set`

### 3.6 해시 테이블 (Hash Table)

| 항목 | 설명 |
|------|------|
| 해시 함수 | key → index 매핑 |
| 충돌 (Collision) | 서로 다른 key가 동일한 index를 가질 때 |
| 해결 방식 | 체이닝(Chaining), 개방 주소법(Open Addressing) |

- 평균 시간 복잡도: O(1)
- 주의: 충돌이 많아지면 성능 저하 (최악 O(n))

---

## 📌 요약 (Summary)

- 배열은 빠른 접근, 연결 리스트는 빠른 삽입/삭제에 유리
- 스택/큐는 선입/후입 구조에 따라 다양한 응용
- 트리/그래프는 비선형 문제 해결에 필수
- 해시 테이블은 거의 모든 면접에서 나옴

---

## 📎 참고 면접 질문 예시

- 배열과 연결 리스트의 차이는?
- 해시 테이블 충돌 해결 방식?
- 이진 탐색 트리의 시간 복잡도는?
- BFS와 DFS의 차이는?
