## [452. Minimum Number of Arrows to Burst Balloons](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/?envType=study-plan-v2&envId=top-interview-150)
**Level: Medium**

---

### ğŸ“ Problem

There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.

Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.

Given the array points, return the minimum number of arrows that must be shot to burst all balloons.

---

### ğŸ’¡ Examples

**Example 1:**
```text
Input: points = [[10,16],[2,8],[1,6],[7,12]]
Output: 2
Explanation: The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].
- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].
```

**Example 2:**
```text
Input: points = [[1,2],[3,4],[5,6],[7,8]]
Output: 4
Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows.
```

**Example 3:**
```text
Input: points = [[1,2],[2,3],[3,4],[4,5]]
Output: 2
Explanation: The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].
- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].
```

---

### âœ… Constraints
- 1 <= points.length <= 105
- points[i].length == 2
- -231 <= xstart < xend <= 231 - 1
---

### âœ… Code

```python
class Solution(object):
    def findMinArrowShots(self, points):

        points.sort(key=lambda x: x[1])
        arrows = 1
        end = points[0][1]

        for i in range(1, len(points)):
            if points[i][0] > end:
                arrows += 1
                end = points[i][1]

        return arrows
```

---

### ğŸ” ì‹œë„ ê³¼ì •

#### ì²« ë²ˆì§¸ ì‹œë„
```python
class Solution(object):
    def findMinArrowShots(self, points):

        points.sort(key=lambda x: x[0])
        overlap = [points[0]]
        for i in range(1, len(points)):
            if overlap[-1][1] >= points[i][0]:
                overlap[-1][1] = max(points[i][1], overlap[-1][1])
            else:
                overlap.append(points[i])
        return len(overlap)
```

#### ë§ˆì§€ë§‰ ì‹œë„ (ì •ë‹µ)
```python
class Solution(object):
    def findMinArrowShots(self, points):

        points.sort(key=lambda x: x[1])
        arrows = 1
        # í’ì„ ì˜ ëë‚˜ëŠ” ì§€ì ì„ í˜„ì¬ í™”ì‚´ì˜ ìœ„ì¹˜ë¡œ ì„¤ì •
        end = points[0][1]

        for i in range(1, len(points)):
            # í˜„ì¬ í’ì„ ì˜ ì‹œì‘ ì§€ì ì´ í˜„ì¬ í™”ì‚´ì˜ ìœ„ì¹˜ë³´ë‹¤ í¬ë‹¤ë©´
            # í˜„ì¬ í™”ì‚´ë¡œëŠ” ì´ í’ì„ ì„ í„°ëœ¨ë¦´ ìˆ˜ ì—†ìŒ
            if points[i][0] > end:
                #ìƒˆ í™”ì‚´, í’ì„ ì˜ ë ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                arrows += 1
                end = points[i][1]

        return arrows
```

---

### ğŸ“Œ ì„¤ëª…
- ì²˜ìŒì—” ì „ì— í’€ì—ˆë˜ 56. Merge Intervalsë¥¼ ìƒê°í•´ì„œ ë²”ìœ„ ê²¹ì¹˜ëŠ” ê²ƒë“¤ ë¼ë¦¬ í•©ì¹˜ê³  ê·¸ ê°¯ìˆ˜ ì„¸ë©´ ëœë‹¤ê³  ìƒê°í–ˆëŠ”ë° ê·¸ ë²”ìœ„ì—ì„œ ë¬¸ì œê°€ ìƒê¹€
1. ì²« ë²ˆì§¸ í’ì„ ì˜ ëì ì—ì„œ í™”ì‚´ì„ ì¨.
2. ê·¸ ëì ë³´ë‹¤ ì‹œì‘ì ì´ í¬ë©´, ìƒˆ í™”ì‚´ì„ ì´ì•¼ í•¨.
3. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ê¸°ì¡´ í™”ì‚´ë¡œ í„°ëœ¨ë¦´ ìˆ˜ ìˆìŒ.